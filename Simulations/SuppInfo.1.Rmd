---
title: "Supporting information 1: Comparing Single- and Repeated-visits occupancy"
subtitle: "A simulation study"
author: "Valentin Lauret, Hélène Labach, Matthieu Authier, Olivier Gimenez"
output:
  html_document:
    highlight: textmate
    theme: readable
    toc: yes
    code_folding: hide
bibliography: SVbib.bib
csl: apa.csl
link-citations: true
---

<style>
p.caption {
  font-style: italic;
}
</style>

Supporting information 1 of article _Using single visits into integrated occupancy models to make the most of existing monitoring programs_.  

Comparing single-visit and repeated-visits occupancy models. For details about single-visit occupancy modelling, refer to @leleDealingDetectionError2012 for its orginial formulation, and @peachSinglevisitDynamicOccupancy2017 for extension to dynamic single-visit occupancy models.

# Methods

## Data simulation 

Required packages

```{r warning=FALSE, message=FALSE}
library(R2jags)
library(tidyverse)
library(cowplot)
```

### State process

The occupancy state $z$ was drawn from a Bernoulli distribution with parameter $\psi$, $z \sim dbern(\psi)$. We wrote $\psi$ as a logistic function of an environmental covariate $\mbox{cov}$:

$$\mbox{logit}(\psi) = \alpha_{0} + \alpha_{1} \; \mbox{cov}$$ 

where $\alpha_{0}$ and $\alpha_{1}$ are unknown parameters that need to be estimated.  

We considered 4 sets of values for the alpha’s:  

  - $\alpha_0 = -1.9$ and $\alpha_1 =  0.2$ that led to $\psi$ approx. equal to 0.1
  - $\alpha_0 = -0.5$ and $\alpha_1 =  0.2$ that led to $\psi$ approx. equal to 0.3
  - $\alpha_0 =  0.5$ and $\alpha_1 =  0.2$ that led to $\psi$ approx. equal to 0.5
  - $\alpha_0 = 2.5$ and $\alpha_1 =  0.15$ that led to $\psi$ approx. equal to 0.9
  
 We used the `sim_state_cov()` function to simulate the $z$ vector that contains the latent ecological state.
 
 <center>
```{r echo=FALSE, message=FALSE, warning=FALSE, fig.cap="Fig.1: Occupancy probability as function of a fictive environmental covariate, 4 scenarii used for simulations", cache = FALSE}
library(tidyverse)
library(cowplot)
covparam.3 <- c(-0.5,0.2,0) # psi = 0.3
covparam.1 <- c(-1.9,0.2,0) # psi = 0.1
covparam.5 <- c(0.5,0.23,0) # psi = 0.5
covparam.9 <- c(2.5,0.15,0) # psi = 0.9

covenv <- runif(100,0,1)
cov_rel.1 <- as.numeric(covparam.1[1]+covparam.1[2]*scale(covenv)+covparam.1[3]*scale(covenv)*scale(covenv))
cov_rel.3 <- as.numeric(covparam.3[1]+covparam.3[2]*scale(covenv)+covparam.3[3]*scale(covenv)*scale(covenv))
cov_rel.5 <- as.numeric(covparam.5[1]+covparam.5[2]*scale(covenv)+covparam.5[3]*scale(covenv)*scale(covenv))
cov_rel.9 <- as.numeric(covparam.9[1]+covparam.9[2]*scale(covenv)+covparam.9[3]*scale(covenv)*scale(covenv))

ggplot() + geom_line(aes(x=covenv,y=1/(1+exp(-cov_rel.3)), color="0.3"), lwd= 2) +
  geom_line(aes(x=covenv,y=1/(1+exp(-cov_rel.1)),color="0.1"), lwd= 2) +
  geom_line(aes(x=covenv,y=1/(1+exp(-cov_rel.5)),color="0.5"), lwd= 2) +
  geom_line(aes(x=covenv,y=1/(1+exp(-cov_rel.9)),color="0.9"), lwd= 2) +
  ylim(0,1) + ylab("Occupancy probability : Ψ") +xlab("Fictive covariate") + theme_bw(base_size = 14) + scale_color_viridis_d(name = "Average Ψ")
```
 </center>


### Observation process

The observations are drawn either from a Bernoulli distribution with parameter $p$ or a multinomial distribution depending on two detection probabilities $p1$ and $p_2$ for the integrated occupancy model. We wrote $p$ as a logistic function of a sampling effort covariate $\mbox{seff}$:

$$\mbox{logit}(p) = \beta_{0} + \beta_{1} \; \mbox{seff}$$ 

where $\beta_{0}$ and $\beta_{1}$ are unknown parameters that need to be estimated.   

We considered 4 sets of values for the beta’s:  

  - $\beta_0 = -1.5$ and $\beta_1 =  0.26$ that led to $p$ approx. equal to 0.15
  - $\beta_0 = -0.6$ and $\beta_1 =  0.25$ that led to $p$ approx. equal to 0.35
  - $\beta_0 = 0.3$ and $\beta_1 =  0.26$ that led to $p$ approx. equal to 0.5
  - $\beta_0 = 1.8$ and $\beta_1 =  0.3$ that led to $p$ approx. equal to 0.8  
  
We used the `sim_obs_cov()` function to simulate the $y$ vector that contains the detections/non-detections.

 <center>
```{r echo=FALSE, message=FALSE, warning=FALSE, fig.cap="Fig.2: Detetion probability as function of a fictive sampling effort, 4 scenarii used for simulations", cache = FALSE}
 Seff.8 <- rnorm(100)#,rnorm(nsites),rnorm(nsites),rnorm(nsites),rnorm(nsites),rnorm(nsites),rnorm(nsites),rnorm(nsites)))
obsparam.5 <- c(0.3,0.26,0) # p = 0.5
obsparam.8 <- c(1.8,0.3,0) # p = 0.8
obsparam.1 <- c(-1.5,0.26,0) # p = 0.5
obsparam.3 <- c(-0.6,0.25,0)

obs_rel.1 <- as.numeric(obsparam.1[1]+obsparam.1[2]*Seff.8+obsparam.1[3]*Seff.8*Seff.8)
obs_rel.3 <- as.numeric(obsparam.3[1]+obsparam.3[2]*Seff.8+obsparam.3[3]*Seff.8*Seff.8)
obs_rel.5 <- as.numeric(obsparam.5[1]+obsparam.5[2]*Seff.8+obsparam.5[3]*Seff.8*Seff.8)
obs_rel.8 <- as.numeric(obsparam.8[1]+obsparam.8[2]*Seff.8+obsparam.8[3]*Seff.8*Seff.8)

ggplot() + geom_line(aes(x=Seff.8,y=1/(1+exp(-obs_rel.8)), color="0.8"), lwd= 2) +
  geom_line(aes(x=Seff.8,y=1/(1+exp(-obs_rel.5)),color="0.5"), lwd= 2) +
  geom_line(aes(x=Seff.8,y=1/(1+exp(-obs_rel.1)),color="0.1"), lwd= 2) +
  geom_line(aes(x=Seff.8,y=1/(1+exp(-obs_rel.3)),color="0.3"), lwd= 2) +
  ylim(0,1) + ylab("Detection probability : p") +xlab("Sampling effort covariate") + theme_bw(base_size = 14) + scale_color_viridis_d(name = "Average p",begin = 0.2, end = 0.9)

```
 </center>

We simulated 4 different sampling occasions for repeated-visit occupancy. For single-visit occupancy, we formatted the data as described in the Methods section. For the sampling effort at site $i$, we summed the sampling effort over the 4 sampling occasions at site $i$, with `seff_sv <- apply(seff_rv,1,sum)`. For the detection/non-detection matrix, we considered the site as occupied if the species was detected at least once over the 4 sampling occasions, with `y_sv <- apply(y_rv,1,max)`.

### Study area 

We simulated $z$ and $y$ for a study area of 100 sites. 

## Models

For each combination of $\psi$ and $p$ we fitted 2 occupancy models:  

  - Repeated-visit occupancy model (RV)
  - Single-visit occupancy model (SV)

We have 16 ecological situations depending on $\psi$ and $p$.  
  
For each scenario, we ran 100 simulations and fitted the 2 occupancy models.

## Performances

To compare the performances of the different occupancy models we calculated the relative bias RB, and the root mean square error over the `S = 100` simulations :  

  - Relative bias: $RB = \frac{1}{S} \sum_{1}^{S} \frac{(\widehat{\theta}_{s}-\theta)}{\theta}$  
  
  - Root Mean Square Error: $RMSE = \sqrt{ \frac{1}{S} \sum_{1}^{S} (\widehat{\theta}_{s}-\theta)^2}$
  
## R codes 

```{r, message=FALSE, warning=FALSE, cache=TRUE}
# load function and data used 

# load functionS
sim_state_cov <- function(nb_sites=nsites,init_occ = covparam, covenv = covenv){
  
  # define various quantities
  R = nb_sites # number of sites
  
  l.psi <- init_occ[1] + init_occ[2] * covenv + init_occ[3] * covenv * covenv
  psi1 <-  1 / ( 1 + exp( -l.psi ))# quadratic relation of the covariate with initial occupancy
  
  # pre-allocate memory
  site <- 1:R # Sites
  
  z <- array(dim = c(R)) # Expected and realized occurrence
  
  # define state process
  # first year/season
  z <- rbinom(R, 1, psi1) # Initial occupancy state
  
  
  return(z)
}
sim_obs_cov <- function(z=z, nb_occ = nocc,Seff, obsparam = obsparam){
  
  # define various quantities
  R = length(z) # number of sites
  K = nb_occ # number of occasions
  
  y <- array(NA, dim = c(R,K))
  p <- array(NA, dim = c(R,K))
  
  # define observation process
  
  for(i in 1:R){
    for(k in 1:K){
      
      l.p <- obsparam[1] + obsparam[2] * Seff[i,k] + obsparam[3] * Seff[i,k] * Seff[i,k]# quadratic relation of the covariate with initial occupancy
      
      p[i,k] <- ( 1 / ( 1 + exp(- l.p )))
      
      prob <- z[i] * p[i,k]
      y[i,k] <- rbinom(1,1, prob= prob)
    } #k
  } #i
  
  
  # format data
  return(y)
}
loopRVSV<- function(nsites, nocc, nsim, covparam, obsparam, Seff, Covenv){
  
  #### allocate memories for estimated parameters ####
  
  p_i <- rep(NA, nsim)
  psi_i <- rep(NA, nsim)

  bcov_i <- rep(NA, nsim)
  bseff_i <- rep(NA, nsim)

  p_ii <- rep(NA, nsim)
  psi_ii <- rep(NA, nsim)

  bcov_ii <- rep(NA, nsim)
  bseff_ii<- rep(NA, nsim)
  
  # allocate RMSE RB
  rbpsi_i    <- rep(NA, nsim)
  rmsepsi_i   <- rep(NA, nsim)
  rbcov_i     <- rep(NA, nsim)
  rmsecov_i <- rep(NA, nsim)
  rbp_i     <- rep(NA, nsim)
  rmsep_i    <- rep(NA, nsim)
  rbseff_i    <- rep(NA, nsim)
  rmseseff_i  <- rep(NA, nsim)

  rbpsi_ii    <- rep(NA, nsim)
  rmsepsi_ii  <- rep(NA, nsim)
  rbcov_ii    <- rep(NA, nsim)
  rmsecov_ii  <- rep(NA, nsim)
  rbp_ii      <- rep(NA, nsim)
  rmsep_ii    <- rep(NA, nsim)
  rbseff_ii   <- rep(NA, nsim)
  rmseseff_ii <- rep(NA, nsim)
  

  #### loop over nsim ####
  for( s in 1:nsim){
    print(s)
    
    # simulate datasets s
    
    z <- sim_state_cov(nb_sites = nsites, covenv= covenv, init_occ= covparam)
    y <- sim_obs_cov(z,nocc,Seff= Seff, obsparam= obsparam)
    
    p <- obsparam
    
    
# WITH Jags
   
    #### i = RV ####
                    
    # Bundle data
    win.data <- list(y = y,nsite = dim(y)[1], nocc = dim(y)[2], Seff = Seff, covenv = covenv)
    
    # Initial values
    zst <- apply(y, 1, max)	# Observed occurrence as inits for z
    
    # inits used for simulation
    psi = covparam[1]    # sum(z)/nsites
    p = obsparam[1]
    bcov <- covparam[2]
    bseff <- obsparam[2]
    
    inits <- function(){ list(z = zst, alpha.psi = psi, alpha.p= p, beta.cov = bcov, beta.seff= bseff)}
    
    # Parameters monitored
    params <- c( "alpha.p","alpha.psi", "beta.cov", "beta.qcov","beta.seff" ,"beta.qseff") 
    
    ni <- 1000
    nc <-  1
    nb <- 200

      
    # Call JAGS from R (BRT 3 min)
    out <- jags(win.data, inits, params, "Occu_cov.jags", n.chains = nc, n.iter = ni, n.burnin = nb, working.directory = getwd())
    
     #head(out$BUGSoutput$summary)
     #denplot(out)
  #effectiveSize(as.mcmc(out))
    # intercept
    p_i[s] <- out$BUGSoutput$mean$alpha.p      
    psi_i[s] <- out$BUGSoutput$mean$alpha.psi

    # slope linear estimate (Q: do we have to save the quadratic estimates-)
    
    bcov_i[s] <- out$BUGSoutput$mean$beta.cov   
    bseff_i[s] <- out$BUGSoutput$mean$beta.seff

    #### ii = SV ####
 
    ysv <-  matrix(apply(y,1,max))
    
    Seffsv <- matrix(apply(Seff,1,sum))
    
    # Bundle data
    win.data <- list(y = ysv,nsite = dim(ysv)[1], nocc = dim(ysv)[2], Seff = Seff, covenv = covenv)
    
    # Initial values
    zst <- apply(ysv, 1, max)	# Observed occurrence as inits for z
    
    # inits used for simulation
    psi = covparam[1]    # sum(z)/nsites
    p = obsparam[1]
    bcov <- covparam[2]
    bseff <- obsparam[2]
    
    inits <- function(){ list(z = zst, alpha.psi = psi, alpha.p= p, beta.cov = bcov, beta.seff= bseff)}
    
    # Parameters monitored
    params <- c( "alpha.p","alpha.psi", "beta.cov", "beta.qcov","beta.seff" ,"beta.qseff") 
    
    ni <- 1500
    nc <-   1
    nb <- 200
    
    
    # Call JAGS from R (BRT 3 min)
    out <- jags(win.data, inits, params, "Occu_cov.jags", n.chains = nc, n.iter = ni, n.burnin = nb, working.directory = getwd())
    
    # head(out$BUGSoutput$summary)
    # denplot(out)
    
    # intercept
    p_ii[s] <- out$BUGSoutput$mean$alpha.p       
    psi_ii[s] <- out$BUGSoutput$mean$alpha.psi 
    
    # slope linear estimate (Q: do we have to save the quadratic estimates-)
    
    bcov_ii[s] <- out$BUGSoutput$mean$beta.cov
    bseff_ii[s] <- out$BUGSoutput$mean$beta.seff

      # save --- RB & SE   
    # i 
    rbpsi_i[s]        <- (psi_i[s]-covparam[1])/covparam[1]   # RB alpha.psi
    rmsepsi_i[s]      <- (psi_i[s] - covparam[1])^2 # RMSE alpha.psi
    
    rbcov_i[s]        <- (bcov_i[s]-covparam[2])/covparam[2]   # RB cov
    rmsecov_i[s]      <- (bcov_i[s] - covparam[2])^2 # RMSE cov
    
    rbp_i[s]          <- (p_i[s]-obsparam[1])/obsparam[1]      # RB alpha p 
    rmsep_i[s]        <- (p_i[s] - obsparam[1])^2 # RMSE alpha p
    
    rbseff_i[s]       <- (bseff_i[s]-obsparam[2])/obsparam[2]   # RB obs
    rmseseff_i[s]     <- (bseff_i[s] - obsparam[2])^2 # RMSE obs
    
    
    # ii
    rbpsi_ii[s]       <- (psi_ii[s]-covparam[1])/covparam[1]   # RB alpha.psi
    rmsepsi_ii[s]     <- (psi_ii[s] - covparam[1])^2 # RMSE alpha.psi
    
    rbcov_ii[s]       <- (bcov_ii[s]-covparam[2])/covparam[2]   # RB cov
    rmsecov_ii[s]     <- (bcov_ii[s] - covparam[2])^2 # RMSE cov
    
    rbp_ii[s]         <- (p_ii[s]-obsparam[1])/obsparam[1]       # RB alpha p 
    rmsep_ii[s]       <- (p_ii[s] - obsparam[1])^2 # RMSE alpha p
    
    rbseff_ii[s]      <- (bseff_ii[s]-obsparam[2])/obsparam[2]   # RB obs
    rmseseff_ii[s]    <- (bseff_ii[s] - obsparam[2])^2 # RMSE obs
    
  
  } # end for 
  
  

  para <- data.frame("nsites" = nsites,"nocc" =  nocc, "nsim" = nsim, "covparam"= covparam, "obsparam"= obsparam)
  
  return(list(para = para, # i 
              rbpsi_i = rbpsi_i,
              rmsepsi_i = rmsepsi_i,
              rbcov_i = rbcov_i,
              rmsecov_i = rmsecov_i,
              rbp_i = rbp_i,
              rmsep_i = rmsep_i,
              rbseff_i = rbseff_i,
              rmseseff_i = rmseseff_i,
              # = #,
              rbpsi_ii = rbpsi_ii,
              rmsepsi_ii = rmsepsi_ii,
              rbcov_ii = rbcov_ii,
              rmsecov_ii = rmsecov_ii,
              rbp_ii = rbp_ii,
              rmsep_ii = rmsep_ii,
              rbseff_ii = rbseff_ii,
              rmseseff_ii = rmseseff_ii))
  
} # endfunction



```

```{r eval=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
# run the analysis
# load param for logistic regressions 
nsites = 100
# occupancy
covparam.3 <- c(-0.5,0.2,0) # psi = 0.3
covparam.1 <- c(-1.9,0.2,0) # psi = 0.1
covparam.5 <- c(0.5,0.23,0) # psi = 0.5
covparam.9 <- c(2.5,0.15,0) # psi = 0.9

covparam <- list(covparam.1 =  covparam.1,
                 covparam.3 =  covparam.3,
                 covparam.5 =  covparam.5,
                 covparam.9 <- covparam.9)

# detection
obsparam.5 <- c(0.3,0.26,0)  # p = 0.5
obsparam.8 <- c(1.8,0.3,0)   # p = 0.8
obsparam.1 <- c(-1.5,0.26,0) # p = 0.1
obsparam.3 <- c(-0.6,0.25,0) # p = 0.3

obsparam <- list(obsparam.1 <- obsparam.1,
                 obsparam.3 <- obsparam.3,
                  obsparam.5 <- obsparam.5,
                 obsparam.8 <- obsparam.8)

# run the analysis 
# generate covariate values 

  Seff <- data.frame(cbind(rnorm(nsites),rnorm(nsites),rnorm(nsites),rnorm(nsites)))
  
  Covenv <- covenv <- runif(nsites,0,1)
  
  res <- list()
  i <- 0
  t <- proc.time()
 for(c in 1: length(covparam)){  #i <- i+1
 
   for(o in 1:length(obsparam)){
    i <- i+1 
    
   print(paste("obs",o))
   print(paste("cov",c))
   res[[i]] <- loopRVSV(nsites = nsites, nocc = nocc, nsim = nsim, covparam = covparam[[c]], obsparam[[o]], Seff, Covenv)

   
   }# end o
   } # end c

  run.time <- proc.time() - t
#
# ------ save results if you want
save(res,run.time, file ="simRVSV.Rdata")

```


# Results

## Covariate effect size 

Regarding the covariate effect size on $\psi$ (Fig.3A-B), we found close RMSE and RB between repeated- and single-visit occupancy. In the case, of high occupancy ($\psi = 0.9$), differences in RB are greater although they are close in precision. Overall, the results were similar whatever the occupancy models we considered.  


<center>
```{r echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE,fig.fullwidth = TRUE, fig.height= 12, fig.width=16 ,fig.cap="Fig. 3: RMSE and RB for all occupancy models"}
load("simRVSV.rdata")
# names res element as the 16 combinations -->  "Psi:p"
 names(res) <- c("0.1:0.1","0.1:0.3","0.1:0.5","0.1:0.8",
                 "0.3:0.1","0.3:0.3","0.3:0.5","0.3:0.8",
                 "0.5:0.1","0.5:0.3","0.5:0.5","0.5:0.8",
                 "0.9:0.1","0.9:0.3","0.9:0.5","0.9:0.8")

# ---- plot the results as in the html file ----
 nsim = 100
 nsites = 100
   Covenv <- covenv <- runif(nsites,0,1)


# make a tibble to store values 
extract.RMSE <- function(res, para){
  m <- c()
  for(i in 1:length(res)){
    m[i] <- sqrt(mean(res[[i]][[para]]))
  } # i
  return(m)
}

extract.RB <- function(res, para){
  m <- c()
  for(i in 1:length(res)){
    m[i] <- mean(res[[i]][[para]])
  } # i
  return(m)
}
 
# liste param               # 1   para
                            # 2   rbpsi_i 
                            # 3   rmsepsi_i
                            # 4   rbcov_i 
                            # 5   rmsecov_i 
                            # 6   rbp_i 
                            # 7   rmsep_i 
                            # 8   rbseff_i 
                            # 9   rmseseff_i 
                            # 
                            # 10  rbpsi_ii 
                            # 11  rmsepsi_ii 
                            # 12  rbcov_ii  
                            # 13  rmsecov_ii 
                            # 14  rbp_ii 
                            # 15  rmsep_ii 
                            # 16  rbseff_ii 
                            # 17  rmseseff_ii
RB.psi <- tibble(model =c("0.1:0.1","0.1:0.3","0.1:0.5","0.1:0.8",
                          "0.3:0.1","0.3:0.3","0.3:0.5","0.3:0.8",
                          "0.5:0.1","0.5:0.3","0.5:0.5","0.5:0.8",
                          "0.9:0.1","0.9:0.3","0.9:0.5","0.9:0.8"),
                 psi.interceptRV = extract.RB(res,2),
                 psi.interceptSV = extract.RB(res,10),
                 psi.covRV = extract.RB(res,4),
                 psi.covSV = extract.RB(res,12)) 
 
RMSE.psi <- tibble(model =c("0.1:0.1","0.1:0.3","0.1:0.5","0.1:0.8",
                            "0.3:0.1","0.3:0.3","0.3:0.5","0.3:0.8",
                            "0.5:0.1","0.5:0.3","0.5:0.5","0.5:0.8",
                            "0.9:0.1","0.9:0.3","0.9:0.5","0.9:0.8"),
                   psi.interceptRV = extract.RMSE(res,3),
                   psi.interceptSV = extract.RMSE(res,11),
                   psi.covRV = extract.RMSE(res,5),
                   psi.covSV = extract.RMSE(res,13))


RB.p <- tibble(model =c("0.1:0.1","0.1:0.3","0.1:0.5","0.1:0.8",
                        "0.3:0.1","0.3:0.3","0.3:0.5","0.3:0.8",
                        "0.5:0.1","0.5:0.3","0.5:0.5","0.5:0.8",
                        "0.9:0.1","0.9:0.3","0.9:0.5","0.9:0.8"),
               p.interceptRV = extract.RB(res,6),
               p.interceptSV = extract.RB(res,14),
               p.covRV = extract.RB(res,8),
               p.covSV = extract.RB(res,16))

RMSE.p <- tibble(model =c("0.1:0.1","0.1:0.3","0.1:0.5","0.1:0.8",
                          "0.3:0.1","0.3:0.3","0.3:0.5","0.3:0.8",
                          "0.5:0.1","0.5:0.3","0.5:0.5","0.5:0.8",
                          "0.9:0.1","0.9:0.3","0.9:0.5","0.9:0.8"),
                 p.interceptRV = extract.RMSE(res,7),
                 p.interceptSV = extract.RMSE(res,15),
                 p.covRV = extract.RMSE(res,9),
                 p.covSV = extract.RMSE(res,17))


  
r <- tibble(model = rep(RMSE.psi$model, 2),
            rmse.occ = c(RMSE.psi$psi.covRV,RMSE.psi$psi.covSV),
            rmse.p = c(RMSE.p$p.covRV,RMSE.p$p.covSV), 
            rb.occ = c(RB.psi$psi.covRV,RB.psi$psi.covSV),
            rb.p = c(RB.p$p.covRV,RB.p$p.covSV)) %>% 
  mutate(type = c(rep("RV",length(model)/2),rep("SV",length(model)/2)),
         occ = c(rep("Ψ = 0.1", 4),rep("Ψ = 0.3", 4),rep("Ψ = 0.5", 4),rep("Ψ = 0.9", 4),
                 rep("Ψ = 0.1", 4),rep("Ψ = 0.3", 4),rep("Ψ = 0.5", 4),rep("Ψ = 0.9", 4)),
         det = rep(c("0.1", "0.3","0.5","0.8"), 8))
             

pocc1 <- r %>%
  ggplot() +
  aes(x = det, y = rmse.occ, fill = type) + 
  geom_col(position = "dodge", width=.6) + 
  labs(x = 'Detection probability',
       y = 'RMSE in occupancy covariate effect size') + 
  scale_fill_manual(name = NULL, values=c("#000A39","#d2a34e"))+ 
    facet_wrap(~ occ,  strip.position = "top", labeller = label_wrap_gen(multi_line = FALSE)) + 
  theme_bw(base_size = 14)

pocc2 <- r %>%
  ggplot() +
  aes(x = det, y = rb.occ, fill = type) + 
  geom_col(position = "dodge", width=.6) + 
  labs(x = 'Detection probability',
       y = 'RB in occupancy covariate effect size') +
  scale_fill_manual(name = NULL, values=c("#000A39","#d2a34e"))+ 
  ylim(-3,5.5) +
  facet_wrap(~ occ,  strip.position = "top", labeller = label_wrap_gen(multi_line = FALSE)) + 
  theme_bw(base_size = 14)

#--------- psi reconstructed -----

# extract parameter
  m <- res
psi.rv <-c()
psi.sv <-c()
psi.t <- c()
rb.psi.rv  <- c()
rmse.psi.rv <- c()
rb.psi.sv  <- c()
rmse.psi.sv <- c()

  for(i in 1:length(res)){
    #for(j in seq(2,16,2)){
      m[[i]][[1]] <- res[[i]][[2]]*  res[[i]][[1]]$covparam[1] +  res[[i]][[1]]$covparam[1] # int Psi RV
        
      m[[i]][[2]] <- res[[i]][[4]]*  res[[i]][[1]]$covparam[2] +  res[[i]][[1]]$covparam[2] # cov Psi RV
      m[[i]][[3]] <- res[[i]][[6]]*  res[[i]][[1]]$obsparam[1] +  res[[i]][[1]]$obsparam[1] # int p RV
      m[[i]][[4]] <- res[[i]][[8]]*  res[[i]][[1]]$obsparam[2] +  res[[i]][[1]]$obsparam[2] # seff RV
      m[[i]][[5]] <- res[[i]][[10]]* res[[i]][[1]]$covparam[1] +  res[[i]][[1]]$covparam[1] # int psi SV
      m[[i]][[6]] <- res[[i]][[12]]* res[[i]][[1]]$covparam[2] +  res[[i]][[1]]$covparam[2] # cov psi SV
      m[[i]][[7]] <- res[[i]][[14]]* res[[i]][[1]]$obsparam[1] +  res[[i]][[1]]$obsparam[1] # int p SV
      m[[i]][[8]] <- res[[i]][[16]]* res[[i]][[1]]$obsparam[2] +  res[[i]][[1]]$obsparam[2] # seff SV
      
      psi.rv <- 1/(1+exp(- m[[i]][[1]] - m[[i]][[2]]*scale(covenv)))
      psi.sv <- 1/(1+exp(- m[[i]][[5]] - m[[i]][[6]]*scale(covenv)))
      psi.t <- 1/(1+exp(- res[[i]][[1]]$covparam[1] - res[[i]][[1]]$covparam[2]*scale(covenv)))
      
      rb.psi.rv[i] <- mean((psi.rv - psi.t)/psi.t)
      rmse.psi.rv[i] <- sqrt(mean((psi.rv - psi.t)^2))
      rb.psi.sv[i] <- mean((psi.sv - psi.t)/psi.t)
      rmse.psi.sv[i] <- sqrt(mean((psi.sv - psi.t)^2))
  } # i


# plot 
r <- tibble(model = rep(RMSE.psi$model, 2),
            rmse.psi = c(rmse.psi.rv,rmse.psi.sv), 
            rb.psi = c(rb.psi.rv,rb.psi.sv)) %>% 
  mutate(type = c(rep("RV",length(model)/2),rep("SV",length(model)/2)),
         occ = c(rep("Ψ = 0.1", 4),rep("Ψ = 0.3", 4),rep("Ψ = 0.5", 4),rep("Ψ = 0.9", 4),
                 rep("Ψ = 0.1", 4),rep("Ψ = 0.3", 4),rep("Ψ = 0.5", 4),rep("Ψ = 0.9", 4)),
         det = rep(c("0.1", "0.3","0.5","0.8"), 8))


ppsi1 <- r %>%
  ggplot() +
  aes(x = det, y = rmse.psi, fill = type) + 
  geom_col(position = "dodge", width=.6) + 
  labs(x = 'Detection probability',
       y = 'RMSE in Ψ') +
  scale_fill_manual(name = NULL, values=c("#000A39","#d2a34e"))+ 
  facet_wrap(~ occ,  strip.position = "top", labeller = label_wrap_gen(multi_line = FALSE)) + 
  theme_bw(base_size = 14)

ppsi2 <- r %>%
  ggplot() +
  aes(x = det, y = rb.psi, fill = type) + 
  geom_col(position = "dodge", width=.6) + 
  labs(x = 'Detection probability',
       y = 'RB in occupancy Ψ') + 
    ylim(-3,5) +
  scale_fill_manual(name = NULL, values=c("#000A39","#d2a34e"))+ 
  facet_wrap(~ occ,  strip.position = "top", labeller = label_wrap_gen(multi_line = FALSE)) + 
  theme_bw(base_size = 14)

plot_grid(pocc1,pocc2, ppsi1, ppsi2,labels = "AUTO", label_size = 20,ncol = 2, nrow = 2)
```


</center>

## Occupancy prediction 

Predicted occupancy probability between single- and repeated-visits models are closed to each other in Fig. 3C-D. However, precision and bias are greater for low occupancy $\psi = 0.1$, which is consistent with @peachSinglevisitDynamicOccupancy2017 findings. Same results when detection probability is low and when $\psi$ is high. Although, note that RMSE plotting scale is different between Fig. 3A and 3C. 

# Discussion

Our simulations study showed that single-visit and repeated-visit occupancy models had similar results in the estimation of covariate effect size for ocucpancy. We explored simple logistic regressions to describe models paramters. To be consistent with our manuscript, we reported performances of covariates effect size and predicted occupancy. To have a complete understanding of models performances, one might want to look at wider range of relationships, and observe all models parameters (e.g. intercept, sampling effort effect size on detection probability).

Overall, our simulation results show that single-visit occupancy models can be used to obtain reliable estimates of occupancy.

# References

